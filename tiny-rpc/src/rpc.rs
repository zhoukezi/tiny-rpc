#[doc(hidden)]
pub mod re_export {
    pub extern crate log;
    pub extern crate serde;

    pub use std::{
        boxed::Box,
        pin::Pin,
        sync::{
            atomic::{AtomicU64, Ordering},
            Arc,
        },
    };

    pub use futures::{Future, Sink, Stream};
    pub use serde_derive::{Deserialize, Serialize};

    pub use super::*;
    pub use crate::error::Error;
}

use std::{collections::HashMap, fmt::Debug, marker::PhantomData, pin::Pin, sync::Arc};

use futures::{
    channel::{mpsc, oneshot},
    future::{select, Either},
    Future, FutureExt, Sink, SinkExt, Stream, StreamExt,
};

use crate::error::Error;

/// The `Rpc` trait defined a rpc service by definding several necessary items.
///
/// The implementation is usually generated by macro.
pub trait Rpc {
    type Request;
    type Response;
}

/// The `RpcServerStub` trait allows making responses for requests.
///
/// The implementation is usually generated by macro.
pub trait RpcServerStub<R: Rpc, I: RpcFrame<R::Request>, O: RpcFrame<R::Response>> {
    fn make_response(self: Arc<Self>, req: I) -> Pin<Box<dyn Future<Output = Option<O>> + Send>>;
}

/// A unique identifier of a rpc call.
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct RequestId(pub u64);

impl std::fmt::Display for RequestId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{:016X}]", self.0)
    }
}

pub trait RpcFrame<T>: Sized + Send + 'static {
    fn from_parts(id: RequestId, data: T) -> Result<Self, Error>;
    fn get_id(&self) -> RequestId;
    fn get_data(self) -> Result<T, Error>;
}

impl<T: Sized + Send + 'static> RpcFrame<T> for (RequestId, T) {
    fn from_parts(id: RequestId, data: T) -> Result<Self, Error> {
        Ok((id, data))
    }

    fn get_id(&self) -> RequestId {
        self.0
    }

    fn get_data(self) -> Result<T, Error> {
        Ok(self.1)
    }
}

pub async fn serve<R, S, I, O, T, U>(
    stub: impl Into<Arc<S>>,
    mut recv: T,
    mut send: U,
) -> Result<(), Error>
where
    R: Rpc,
    S: RpcServerStub<R, I, O>,
    I: RpcFrame<R::Request>,
    O: RpcFrame<R::Response>,
    T: Stream<Item = I> + Unpin,
    U: Sink<O, Error = Error> + Unpin,
{
    let stub: Arc<S> = stub.into();

    let (tx, mut rx) = mpsc::channel::<O>(128);
    let mut fut = select(recv.next(), rx.next());
    loop {
        match fut.await {
            Either::Left((Some(req), r)) => {
                let stub = stub.clone();
                let mut tx = tx.clone();
                tokio::spawn(stub.make_response(req).then(move |res| async move {
                    if let Some(res) = res {
                        tx.send(res).await.expect("driver closed unexpectedly")
                    }
                }));
                fut = select(recv.next(), r);
            }
            Either::Right((Some(rsp), r)) => {
                send.send(rsp).await?;
                fut = select(r, rx.next());
            }
            _ => {
                // None is returned from client or remote. Stop driver.
                break Ok(());
            }
        }
    }
}

pub struct RpcClient<'a, R: Rpc, I: RpcFrame<R::Response>, O: RpcFrame<R::Request>>(
    mpsc::Sender<(oneshot::Sender<Result<I, Error>>, O)>,
    PhantomData<&'a R>,
);

impl<R: Rpc, I: RpcFrame<R::Response>, O: RpcFrame<R::Request>> RpcClient<'static, R, I, O> {
    pub fn new<
        T: Stream<Item = I> + Unpin + Send + 'static,
        U: Sink<O, Error = Error> + Unpin + Send + 'static,
    >(
        recv: T,
        send: U,
    ) -> Self {
        let (d, r) = Self::new_with_driver(recv, send);
        tokio::spawn(d);
        r
    }
}

impl<'a, R: Rpc, I: RpcFrame<R::Response>, O: RpcFrame<R::Request>> RpcClient<'a, R, I, O> {
    pub fn new_with_driver<T, U>(recv: T, send: U) -> (impl Future<Output = ()> + 'a, Self)
    where
        T: Stream<Item = I> + Unpin + 'a,
        U: Sink<O, Error = Error> + Unpin + 'a,
    {
        async fn driver<'a, R, I, O, T, U>(
            mut rx: mpsc::Receiver<(oneshot::Sender<Result<I, Error>>, O)>,
            mut recv: T,
            mut send: U,
        ) where
            R: Rpc,
            I: RpcFrame<R::Response>,
            O: RpcFrame<R::Request>,
            T: Stream<Item = I> + Unpin + 'a,
            U: Sink<O, Error = Error> + Unpin + 'a,
        {
            let mut fut = select(rx.next(), recv.next());
            let mut req_map = HashMap::with_capacity(128);
            loop {
                match fut.await {
                    Either::Left((Some((callback, req)), r)) => {
                        let id = req.get_id();
                        if let Err(e) = send.send(req).await {
                            callback
                                .send(Err(e))
                                .unwrap_or_else(|_| panic!("client closed unexpectedly"));
                        } else {
                            if req_map.insert(id, callback).is_some() {
                                panic!("request id is not unique")
                            }
                        }
                        fut = select(rx.next(), r);
                    }
                    Either::Right((Some(rsp), r)) => {
                        let id = rsp.get_id();
                        if let Some(callback) = req_map.remove(&id) {
                            callback
                                .send(Ok(rsp))
                                .unwrap_or_else(|_| panic!("client closed unexpectedly"));
                        } else {
                            warn!("Server responeded for nonexist request: {}", id);
                        }
                        fut = select(r, recv.next());
                    }
                    _ => {
                        // None is returned from client or remote. Stop driver.
                        break;
                    }
                }
            }
        }

        let (tx, rx) = mpsc::channel::<(oneshot::Sender<Result<I, Error>>, O)>(128);
        (
            driver::<'a, R, I, O, T, U>(rx, recv, send),
            Self(tx, PhantomData),
        )
    }

    pub async fn make_request(&mut self, req: O) -> Result<I, Error> {
        let (tx, rx) = oneshot::channel();
        self.0
            .send((tx, req))
            .await
            .expect("driver closed unexpectedly");
        rx.await.expect("driver closed unexpectedly")
    }
}

impl<'a, R: Rpc, I: RpcFrame<R::Response>, O: RpcFrame<R::Request>> Debug
    for RpcClient<'a, R, I, O>
{
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "RpcClient")
    }
}

impl<'a, R: Rpc, I: RpcFrame<R::Response>, O: RpcFrame<R::Request>> Clone
    for RpcClient<'a, R, I, O>
{
    #[inline]
    fn clone(&self) -> Self {
        Self(self.0.clone(), PhantomData)
    }
}
